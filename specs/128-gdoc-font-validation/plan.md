# Implementation Plan: Google Docs Font Validation

**Branch**: `128-gdoc-font-validation` | **Date**: 2026-01-12 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/128-gdoc-font-validation/spec.md`

## Summary

Implement font validation in the MEBDF import layer to prevent silent font fallback to Arial. When LLMs specify invalid fonts or unsupported weights, the system returns clear error messages with suggestions instead of silently rendering incorrect fonts. The font catalog is embedded in tool descriptions to guide LLM usage without adding new MCP tools.

## Technical Context

**Language/Version**: Python 3.11+
**Primary Dependencies**: google-api-python-client (existing), dataclasses (stdlib)
**Storage**: N/A (stateless validation)
**Testing**: pytest (existing), tier_a for unit tests, tier_b for integration
**Target Platform**: MCP server (local Python process)
**Project Type**: Single project
**Performance Goals**: Validation adds <1ms per font property (pure in-memory lookup)
**Constraints**: No new MCP tools (per spec SC-005), font catalog hardcoded (no external API calls)
**Scale/Scope**: ~35 font families in catalog, validation on every import operation

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

Verify compliance with Extended Google Doc Utils Constitution v1.0.0:

- [x] **I. LLM-Friendly Format Design**: Font syntax remains `{!font:Name, weight:N}` - minimal and consistent with existing MEBDF
- [x] **II. Round-Trip Safety**: Validation ensures fonts render correctly on import, export already handles fonts
- [x] **III. Minimal Verbosity**: No changes to syntax verbosity, validation is transparent
- [x] **IV. Backward Compatibility**: Valid fonts continue to work, only invalid fonts now error (was silent failure)
- [x] **V. Specification-Driven Development**: Spec complete before implementation

**Testing Standards**:
- [x] Contract tests planned for font validation functions
- [x] Round-trip tests planned to verify fonts actually render (not fall back to Arial)
- [x] LLM integration via tool descriptions (font catalog embedded)
- [x] Edge cases identified: variant names, case sensitivity, invalid weights

## Project Structure

### Documentation (this feature)

```text
specs/128-gdoc-font-validation/
├── plan.md              # This file
├── research.md          # Font validation research findings
├── data-model.md        # Font catalog data structures
├── quickstart.md        # Implementation guide
├── contracts/           # Internal API contracts
│   └── font-validation.md
└── tasks.md             # Generated by /speckit.tasks
```

### Source Code (repository root)

```text
src/extended_google_doc_utils/
├── converter/
│   ├── font_catalog.py      # NEW: Font catalog and validation functions
│   ├── mebdf_to_gdoc.py     # MODIFY: Add validation calls
│   └── exceptions.py        # MODIFY: Add FontValidationError
└── mcp/
    ├── errors.py            # MODIFY: Add FontValidationMcpError
    └── tools/
        ├── tabs.py          # MODIFY: Update docstring with font catalog
        └── sections.py      # MODIFY: Update docstring with font catalog

tests/
├── tier_a/
│   ├── test_font_catalog.py     # NEW: Unit tests for validation
│   └── test_mebdf_to_gdoc.py    # MODIFY: Add validation error tests
└── tier_b/
    └── test_font_rendering.py   # NEW: Integration tests for font round-trip
```

**Structure Decision**: Single project structure (existing). New `font_catalog.py` module in converter layer for clean separation of font data and validation logic.

## Design Decisions

### 1. Font Catalog Approach

**Decision**: Hardcoded catalog of ~35 Google Docs default fonts

**Rationale**:
- Spec explicitly states "default Google Doc fonts only"
- Avoids external API dependencies (Google Fonts API)
- Catalog is stable - default fonts rarely change
- Enables offline validation

### 2. Validation Location

**Decision**: Validate in `mebdf_to_gdoc.py` during `serialize_node()` processing

**Rationale**:
- Single validation point for both tab and section imports
- Early failure before any API calls
- Clear error attribution to MEBDF content

### 3. Error Handling Strategy

**Decision**: Raise `FontValidationError`, let MCP layer convert to response

**Rationale**:
- Consistent with existing exception handling pattern (see `MebdfParseError`)
- Clean separation between converter logic and MCP response formatting
- Enables useful error details (font name, suggestions) to bubble up

### 4. Tool Description Updates

**Decision**: Embed abbreviated font catalog in tool docstrings

**Rationale**:
- Per spec SC-005, no new MCP tools
- Tool descriptions are visible to LLMs when they call the tool
- Lists fonts by category for quick reference
- Full weights not listed (too verbose), but common ones shown

### 5. Case-Insensitive Matching

**Decision**: Accept fonts case-insensitively, normalize to canonical casing

**Rationale**:
- Improves LLM usability (may generate "roboto" instead of "Roboto")
- Google Docs API is somewhat case-tolerant
- No ambiguity risk (font names are unique even case-folded)

### 6. Variant Name Detection

**Decision**: Detect common variant patterns and provide helpful error

**Rationale**:
- "Roboto Light" as font family is a common mistake
- Detection helps LLMs learn correct syntax
- Suggestion points to correct approach: `{!font:Roboto, weight:300}`

## Key Implementation Details

### Font Catalog Structure

```python
GOOGLE_DOCS_FONTS = {
    "roboto": FontCatalogEntry("Roboto", [100, 300, 400, 500, 700, 900], "sans-serif"),
    "arial": FontCatalogEntry("Arial", [400, 700], "sans-serif"),
    # ... 30+ more fonts
}
```

### Validation Integration Point

In `mebdf_to_gdoc.py`, `serialize_node()` around line 565:

```python
elif "font" in props:
    font_value = props["font"]
    result = validate_font_family(font_value)
    if not result.is_valid:
        raise FontValidationError(...)
    font_family = result.canonical_name

if "weight" in props and font_family:
    result = validate_font_weight(font_family, weight_value)
    if not result.is_valid:
        raise FontValidationError(...)
    font_weight = result.normalized_weight
```

### Testing: Verifying Actual Font Rendering

**Critical insight from user**: Previous tier_b tests passed but fonts didn't render correctly. The fix:

```python
def test_font_renders_correctly():
    # 1. Import with Roboto
    converter.import_tab(tab, "{!font:Roboto}text{/!}")

    # 2. Export and verify font persisted (not Arial fallback)
    exported = converter.export_tab(tab)
    assert "Roboto" in exported.content  # KEY: round-trip verification
```

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Font catalog missing commonly used font | Low | Medium | Include all default menu fonts, document how to extend |
| Variant detection has false positives | Low | Low | Use strict pattern matching on known weight names |
| Case normalization causes issues | Very Low | Low | Google Docs API handles casing; we match their behavior |

## Complexity Tracking

No constitution violations requiring justification. Design follows existing patterns:
- Exception hierarchy (like `MebdfParseError`)
- MCP error responses (like `AnchorNotFoundError`)
- Validation functions (like `parse_font_weight()`)
